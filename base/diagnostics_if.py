'''
Interfaces for diagnostic rules that allow checking properties of modules.
Parts are even more general.

Created on 26.05.2012

@author: SIGIESEC
'''
from commons.config_if import AutoConfigurable

class CheckerRuleFactory(AutoConfigurable):
    """
    An abstract factory of ModuleCheckerRule instances.
    
    @rtype: An iterator of ModuleCheckerRule instances
    """
    def rules(self):
        raise NotImplementedError(self.__class__)


class DiagnosticDescription(object):
    """
    Encapsulates a diagnostic description which are specific for the diagnostics of a rule.
    @param id: a unique id for the rule and its attributes
    @param dynamicID: a shorter ID which is readable and let identify the rule
    @param severity: how important the diagnostic result is
    @param description: what the rule checks
    @param subjectType: on what type of subject is the diagnostic applied to (see 
    @param documentationLink: link to further documentation f.e. to the wiki
    """
    def __init__(self, dynamic_ID, severity, view_name, description, subject_type, documentation_link, example="", ID=''):
        self.__id = ID
        self.__dynamic_ID = dynamic_ID
        self.__severity = severity
        self.__view_name = view_name
        self.__description = description
        self.__subject_type = subject_type
        self.__example = example
        self.__documentation_link = documentation_link
        
    def __str__(self):
        return ("Diagnostic Description(dynamic id= %s, severity = %i, description = %s, subject type = %s") \
            %(self.__dynamic_ID, self.__severity, self.__description, self.__subject_type)
    
    def get_ID(self):
        raise NotImplementedError(self.__class__)
    
    def get_dynamic_ID(self):
        return self.__dynamic_ID
    
    def get_severity(self):
        return self.__severity
    
    def get_view_name(self):
        return self.__view_name
    
    def get_description(self):
        return self.__description
    
    def get_subject_type(self):
        return self.__subject_type

    def get_example(self):
        if self.__example == "":
            return [("no example available","")]
        else:
            return self.__example
            
    def get_documentation_link(self):
        return self.__documentation_link
    
class DiagnosticResult(object):
    """
    Encapsulates a diagnostic result, which are generated by implementations of base.diagnostics_if.ModuleCheckerRule.
    
    @param level: the severity of the diagnostic result
    @param message: description of the diagnostic result
    @param subject: to which subject refers the diagnostic result
    @param subjectType: the type of the subject to which the diagnostic result refers to
    @param diagnostic_discription see class DiagnosticDiscription
    TODO: Align with the DiagnosticResult classes in BTC.CAB.Checker (.NET)
    TODO: Delete the default parameter and fit all Rules.
    """
    def __init__(self, level, message, subject='', subject_type='', diagnostic_description=''):
        self.__level = level
        self.__message = message
        self.__subject = subject
        self.__subject_type = subject_type
        self.__diagnostic_description = diagnostic_description
        
    def get_level(self):
        return self.__level
    
    def get_message(self):
        return self.__message
    
    def get_subject(self):
        return self.__subject
    
    def get_subject_type(self):
        return self.__subject_type
    
    def get_diagnostic_description(self):
        return self.__diagnostic_description
    
    def __str__(self):
        return "DiagnosticResult(level=%i, message=%s, subject=%s, diagnostic description=%s)" \
            % (self.__level, self.__message, self.__subject, self.__diagnostic_description)         
    
     
class CheckerRule(object):
    """
    A checker rule provides a specific check of a module specification.  
    
    @see: Consider base.diagnostics_util.ModuleCheckerRuleBase for a base implementation 
    that might fit the majority of rule implementations. 
    """
    def check(self, data):
        """
        @param data: A description of the module that is to be checked. Standard keys are 
          defined by the constants in diagnostics_if.ModuleCheckerParameterKeys. Typically, 
          a rule refers only to a subset of these keys. Further, e.g. technology-specific 
          keys may be used.
        @type data: A (frozen) string to string dictionary
        @rtype: iterator of DiagnosticResult
        """
        raise NotImplementedError(self.__class__)


class CheckerParameterKeys(object):
    MODULES_IN_SOLUTIONS = "Dic with Solution Files and mapped Modules in this Solution"
    MODULE_CHECKER_PARAMETER = "Dic with Modules and mapped checker parameter"
    SOURCE_FILE_LIST = "List of all source files"

class ModuleCheckerParameterKeys(object):
    """
    Defines several standard keys that are used to describe the data passed to ModuleCheckerRule instances.
    The literal values of the constants defined here are not assumed to form part of the interface and may change 
    without notice.
    
    Extension note: Currently, there is no registration mechanism for additional keys. To avoid name clashes,
    it is safe to construct the keys by prefixing them with the (full) class name.
    """

    ANALYSIS_BASE_DIRS="analysisBaseDirs"        
    EXPLICIT_MODULE_NAME="explicitModuleName"
    BINARY_BASENAME="binaryBasename"
    MODULE_SPECIFICATION_FILE_BASENAME="moduleSpecificationFileBasename"
    MODULE_SPECIFICATION_FILE_DIRNAME="moduleSpecificationFileDirname"
    SOURCE_ROOT_DIRNAME="sourceRootDirname"
    ROOT_NAMESPACE="rootNamespace"
    SOURCE_FILES="sourceFiles"
    IGNORED_FILES="ignoredFiles"


class DiagnosticSubjectTypeParameterKeys(object):
    """
    Defines the standard parameters for subject types in DiagnosticResult and DiagnosticDescription
    """
    
    SOLUTION="solution"
    MODULE="module"
    MODULE_SPECIFICATION_FILE="module specification file"
    SOURCE_FILE="source file"


class CheckerRuleType(object):
    """
    Different types for which rules are defined.
    """
    MODULE_RULE = "module rule"
    SOURCEFILE_RULE = "source files rule"
    GLOBAL_RULE = "global rules"

class TechnologyTypes(object):
    """
    Technologies for which different rules are defined.
    """
    CPP = "cpp"
    DOTNET = ".NET"